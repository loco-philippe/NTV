<?xml version="1.0" encoding="utf-8"?>

<?xml-model href="rfc7991bis.rnc"?>  


<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="info"
  docName="draft-thomy-json-ntv"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  version="0">

  <front>
    <title abbrev="JSON-NTV">JSON-NTV semantic format</title>
    <seriesInfo name="Internet-Draft" value="draft-thomy-json-ntv"/>
    <author fullname="Philippe THOMY" initials="P" role="editor" surname="THOMY">
      <organization>Loco-labs</organization>
      <address>
        <postal>
          <street>476 chemin du gaf de Famian</street>
          <city>BOLLENE</city>
          <code>84 500</code>
          <country>FR</country>
        </postal>        
        <email>philippe@loco-labs.io</email>  
        <uri>https://github.com/loco-philippe/NTV/blob/main/README.md</uri>
      </address>
    </author> 
    <date year="2023"/>
    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>JSON SEMANTIC</keyword>

    <abstract>
      <t>This document describes a set of simple rules for unambiguously and concisely encoding semantic data into 
      JSON Data Interchange Format <xref target="RFC8259" />. These rules and framework, called JSON-NTV (JSON with 
      Named and Typed Values), relies on the rules defined in the <xref target="JSON-ND" />.
      </t>
    </abstract>
  </front>

  <middle>
    <section><name>Introduction</name>
      <section><name>Presentation</name>
        <t>Today, the semantic level of shared data remains low. It is very often limited to the type of data defined 
        in the exchange formats (strings for CSV formats; numbers, strings, arrays and objects for JSON formats).</t>
        <t>JSON-NTV proposes to increase the semantic level of the JSON entities by adding two additional pieces of information
         to a JSON entity :<ul>
          <li><strong>name</strong>: interpretation of the value in human language or detailed information (e.g., “beginning of the observation”)
            or link to external information(e.g., “https://github.com/loco-philippe/Environmental-Sensing/tree/main”),</li>
          <li><strong>type</strong>: interpretation of the value in a data standard (e.g. GeoJSON, datetime) or in a data catalog or 
          in a software language.</li></ul>
        </t>
        <t>The NTV entity is thus a triplet with a mandatory element (value) and two additional elements (name, type). </t>
        <ul empty="true">
          <li><em>For example, Paris location can be represented by : </em><ul spacing="compact">
            <li><em>a name : “paris”,</em></li>
            <li><em>a type : geoJSON Point coordinates,</em></li>
            <li><em>a value : [2.3522, 48.8566]</em></li>
          </ul></li>
        </ul>
        <t>The easiest way to add that information into a JSON-value is to use a JSON-object with a single member using 
        the syntax JSON-ND for the first term of the member and the JSON-value for the second term of the member.</t>
        <ul empty="true">
          <li><em>The JSON value of the previous example is:</em><ul spacing="compact" empty="true">
            <li><em>{ “paris:point” : [2.3522, 48.8566] }</em></li>
          </ul></li>
        </ul>
        <t>With this approach, two NTV entities are defined :<ul>
          <li><strong>a primitive entity</strong> which is not composed of any other entity,</li>
          <li><strong>a structured entity</strong> which is an ordered sequence of NTV entities.</li></ul>
        as well as two JSON formats depending on the presence of the additional elements : <ul>
          <li><strong>simple format</strong> when name and type are not present</li>
          <li><strong>named format</strong> when name or type is present </li></ul></t>
        <ul empty="true">
          <li><em>Example (entity composed of two other primitive entities): </em><ul spacing="compact" empty="true">
            <li><em>{ “cities::point”: [[2.3522, 48.8566], [4.8357, 45.7640]] } </em></li>
            <li><em>{“cities::point”: {“paris”:[2.3522, 48.8566], “lyon”:[4.8357, 45.7640]}}</em></li>
          </ul></li>
        </ul>
        <t>A JSON-NTV generator produces a JSON-value from a NTV entity and vice versa a JSON-NTV parser transforms a 
        JSON-value into a NTV entity. </t>
        <t>The conversion between NTV entity and software object is not the subject of this note.</t>
      </section>
      
      <section><name>Key design features</name>
        <t>The format’s focus is on simplicity, lightness and web usage.</t>
        <t>The key features of this format are the following: <ul>
          <li>JSON as the base format<ul>
            <li>JSON is simple and readable as simple text</li>
            <li>JSON supports rich structure including nesting and basic types</li>
            <li>JSON is web-native and very widely used and supported</li>
            <li>JSON format has binary representation (i.e. CBOR format)</li></ul></li>
          <li>high semantic level of data<ul>
            <li>wide variety of data typing</li>
            <li>tree-like and customisable data typing </li></ul></li>
          <li>compatibility with existing formats<ul>
            <li>JSON data is a JSON-NTV data</li>
            <li>most of NTV types are existing types</li>
            <li>the defined types integrate the data catalogs (i.e.  schemaorg, darwincore)</li></ul></li>
          <li>compatibility with any type of platform<ul>
            <li>types and structures are independent of software and hardware platforms</li>
            <li>the NTV concept is applicable to all types of software and data</li></ul></li>
          <li>reversibility<ul>
            <li>the NTV entity coming from a Json is identical to the NTV entity from which the Json comes</li>
            <li>the Json representation of an NTV entity is the same as the Json value used to construct the NTV entity</li></ul></li>
        </ul></t>
      </section>
      
      <section><name>Requirements Language</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.</t>
        <t>This document also uses the following terms:</t><dl newline="true">    
          <dt><strong>JsonType, JsonText, JsonName, JsonValue, JsonObject, JsonMember, JsonElement, JsonArray, JsonNumber, JsonString, JsonFalse, JsonNull, JsonTrue:</strong></dt>
          <dd>These terms are defined as type, text, name, value, object, member, element, array, number, string, false, null, true in the JSON grammar.</dd>
          <dt><strong>JsonPrimitive:</strong></dt>
          <dd>A JsonNumber, JsonString, JsonFalse, JsonTrue or JsonNull.</dd>
          <dt><strong>NTVsingle, NTVlist:</strong></dt>
          <dd>NTVlist and NTVsingle entities can be abbreviated as:<ul>
                <li>NVsingle, NVlist : entity without NTVtype</li>
                <li>TVsingle, TVlist : entity without NTVname</li>
                <li>Vsingle, Vlist : entity without NTVtype and without NTVname</li></ul>
          </dd>
        </dl>
      </section>
    </section>
    
    <section><name>NTV structure</name>
      <section><name>NTV entities</name>
        <t>The NTV entity is a triplet (NTVvalue, NTVtype, NTVname).</t>
        <t>The triplet contains all the data needed to reconstruct the software object.</t>
        <t>Two categories of entities (one primitive and one structured) are defined:<ul>
          <li>NTVsingle for the primitive entity,</li>
          <li>NTVlist for an ordered sequence of NTV entities</li></ul></t>
        <t>Entities are defined in <xref target="NTVentities-abnf" format="default" sectionFormat="of" derivedContent="Figure 1"/>, 
        which uses ABNF from <xref target="RFC3339" format="default" sectionFormat="of" derivedContent="RFC3339"/>.</t>
        <figure anchor="NTVentities-abnf" align="left" suppress-title="false" pn="figure-1">
          <name>NTV entities - ABNF</name>
          <sourcecode type="abnf" markers="false" pn="section-1">
  ; notation:
  ;   "Object(" *param ")" represent an Object defined by a list of parameters (param)
  
  ;   JsonArray(*param) represent a JsonArray as defined in the Json grammar, 
  ;   *param is a list of JsonElement
  ;   JsonObject(*param) represent a JsonObject as defined in the Json grammar, 
  ;   *param is a list of JsonMember
  ;   JsonValue represent a JsonValue as defined in the Json grammar

  NTVentity = NTVsingle / NTVlist
  
  NTVsingle = "NTVsingle(" NTVsingleValue  NTVname  NTVsingleType ")"
  NTVsingleType   = NTVtype 
  NTVsingleValue  = JsonValue / NTVsingle

  NTVlist   = "NTVlist(" NTVlistValue  NTVname  NTVlistType ")"
  NTVlistType     = NTVtype / Namespace
  NTVlistValue    = *NTVentity
  
  NTVname         = string
  JsonValue       = string

  string      = DQUOTE *CHAR DQUOTE
  DQUOTE   = %x22          ; " double quote
  CHAR     = %x01-7F

          </sourcecode>
        </figure>
        <section><name>NTVsingle</name>
          <t>The NTVvalue (NTVsingleValue) is the JSON representation of the NTV entity (JsonValue) or another NTVsingle entity.</t>
          <t>The NTVtype (NTVsingleType) defines the type of entity and the conversion rules between the NTV entity and the NTVvalue. The default value is the "json" type.</t>
          <t>The NTVname is a string</t>
          <t><strong>In other words, any entity that has on the one hand a function of encoding it into a json value and on the other hand a function of creating from a json value can be taken into account.
          This approach is very general because the majority of computer objects are defined by a list of parameters (e.g. *args in python) and/or a list of key/values (e.g. **kwargs in python) 
          which simply translate into a JSON-Array or a JSON-Object.</strong></t>
        </section>
        <section><name>NTVlist</name>
          <t>The NTVvalue (NTVlistValue) is the list of included NTV entities.</t>
          <t>The NTVtype (NTVlistType) is a Namespace or a default NTVtype to apply to the NTV entities included. This NTVtype avoids having to include a type (if default NTVtype) 
          or reduce the length (if Namespace) in the JSON representation of the included NTV entities. The default value is "None".</t>
          <t>The NTVname is a string.</t>
          <ul empty="true">
            <li><em>Example of equivalent JSON representations:</em><ul spacing="compact" empty="true">
              <li><em>where NTVtype is None for the NTVlist</em><ul spacing="compact" empty="true">
                <li><em>[ { ":point" : [2.3522, 48.8566]}, {":point" : [4.8357, 45.7640]} ] </em></li>
              </ul></li>
              <li><em>where NTVtype is "point" for the NTVlist</em><ul spacing="compact" empty="true">
                <li><em>{ ":point" : [ [2.3522, 48.8566], [4.8357, 45.7640] ] }</em></li>
              </ul></li>
            </ul></li>
            <li><em>If JSON-value is { "::dat" : ["2022-01-28T18-23-54", {":point": [1, 2] ] } }, 
            the parsers deduce that the first NTVvalue has a  "dat" NTVtype and the second a "point" NTVtype.</em></li>
          </ul>
        </section>
      </section>
      <section><name>NTVtype</name>
        <t>NTVtype and associated Namespace  are defined in <xref target="NTVtype-abnf" format="default" sectionFormat="of" derivedContent="Figure 2"/>, 
        which uses ABNF from <xref target="RFC3339" format="default" sectionFormat="of" derivedContent="RFC3339"/>.</t>
        <figure anchor="NTVtype-abnf" align="left" suppress-title="false" pn="figure-2">
          <name>NTVtype - ABNF</name>
          <sourcecode type="abnf" markers="false" pn="section-2">
  ; Namespace and NtvType

Namespace       = "Namespace(" NamespaceName  NamespaceParent ")" 
NamespaceParent = Namespace  ; Namespace is nested
NamespaceName   = [ ["$"] string "." ]  ; global namespace has an empty name
JsonNamespace   = JsonNamespaceParent NamespaceName
JsonNamespaceParent = JsonNamespace

NTVtype         = "NTVtype(" NTVtypeName  NamespaceParent [NTVtypeGen] ")"
NTVtypeGen      = NTVtype
NTVtypeName     = ["$"] string
JsonNTVtype     = JsonNamespaceParent NTVtypeName  

          </sourcecode>
        </figure>
        <t>A NTVtype is defined by a name (NTVtypeName) and a Namespace parent (NamespaceParent). 
        The NTVtype is unique in the Namespace parent.</t>

        <t>NTVtype and the rules to encode or decode NTVvalues MUST be understood by data producers and data consumers.</t>
        <t>So NTVtype and rules associated have to be defined in a specification shared by a large community.
        On the other hand, it must be possible for everyone to share data according to their own data structure.
        There are therefore two categories of data: 
        custom NTVtype (and Namespace) which can be created by anyone without control,
        shared NTVtype (and Namespace) that are defined and used in a single, shared repository.
        The corresponding rules are as follows:
        NTVtype (or Namespace) whose name begins with '$' is of type 'custom'
        NTVtype (or Namespace) included in a Namespace of type 'custom' is also of type 'custom'
        Each 'shared' Namespace or NTVtype is uniquely managed.
        Example: 
        If "fr." is a Namespace attached to the global Namespace and containing the Namespace 'BAN.' and the NTVtype 'dep', then: 
        "fr.dep" is a shared NTVtype,
        "fr.$test" is a custom NTVtype,
        "fr.$example.one" is a custom NTVtype
        "fr.BAN.$test" is a custom NTVtype

        A Namespace is represented by a string followed by a point (NamespaceName).
        Namespaces may be nested: a Namespace is included in a Namespace parent (NamespaceParent) and may contain Namespace child  
        The global Namespace (root node in the Namespace tree) is represented by an empty string and its NamespaceParent is None. 

        The Namespace representations are added to the value of an NTVtype to have an absolute representation of an NTVtype (JsonNTVtype).

        Example for an absolute representation of an NTVtype defined in two nested Namespace in the global Namespace:
        "ns1.ns2.type" 
        where:
        ns1. is a Namespace defined in the global Namespace,
        ns2. is a Namespace defined in the ns1. Namespace,
        type is a NTVtype defined in the ns2. Namespace

        Example for a NVTtype defined in the global Namespace : 
        "type"
        where:
        type is a NTVtype defined in the global Namespace

        Three categories of NTVtype are defined (None, Simple, Generic).
        The "None" NTVtype is used with NTVlist to indicate the absence of a default Type.
        If NTVtype is Simple, the rules associated with the NTVtype are used  for the conversion between an entity and a NTVvalue.
        The Generic NTVtype (NTVtypeGen) is equivalent to a set of Simple NTVtype. 
        This indicates that parsers can use an associated simple NTV type to decode the JsonNTVvalue.

        Example : 
        "dat" is the generic NTVtype for "datetime" and "timeposix"
        If a JSONvalue is { "::dat" : ["2022-01-28T18-23-54", 123456.78] }, the parser deduce that the NTVvalue of included entities has a NTVtype with a "dat" NTVtypeGen. 
        The parser of included NTV entities deduces that the first object has an equivalent "datetime" NTVtype and the second an equivalent "timeposix" NTVtype.

        This structuring of type makes it possible to reference any type of data that has a JSON representation and to consolidate 
        all the shared data structures within the same tree of types.</t>

      </section>      
      <section><name>examples</name>
        <ol>
          <li>Ordered list item [REPLACE/DELETE]</li>
        </ol>
        
        <ul>
          <li>Bulleted list item [REPLACE/DELETE]</li>
        </ul>
        
        <table>
          <thead>
          <!-- [REPLACE/DELETE] a table header is optional -->
            <tr><th>Column 1 [REPLACE]</th></tr>
          </thead>
          <tbody>
            <tr><td>Cell [REPLACE]</td></tr>
          </tbody>
        </table>

        <figure>
          <name>Source [REPLACE]</name>
          <sourcecode name="suggested filename [REPLACE/DELETE]" type="language [REPLACE/DELETE]" markers="true">
            <![CDATA[
  source code goes here [REPLACE]
            ]]>
          </sourcecode>
          <!-- [CHECK] markers="true" means that the rendered file will have <CODE BEGINS> and <CODE ENDS> added -->
        </figure>

        <figure>
          <name>Diagram [REPLACE]</name>
          <artset>
          <!-- This <artset> includes two <artwork> elements, each of a different type -->
            <artwork type="svg" src="https://www.rfc-editor.org/materials/format/svg/stream.svg" />
            <!-- [REPLACE] src points to either a local file or a URI. -->
            <artwork type="ascii-art" name="stream.txt">
              <!-- [REPLACE/DELETE] name recommends a filename to use if the diagram is extracted -->  
              <![CDATA[
  ascii-art diagram goes here [REPLACE]
              ]]>
            </artwork>
          </artset>
        </figure>
      </section>
    </section>   
    
    <section anchor="IANA"><name>IANA Considerations</name>
    <!-- All drafts are required to have an IANA considerations section. See RFC 8126 for a guide.-->
      <t>This memo includes no request to IANA. [CHECK]</t>
    </section>
    
    <section anchor="Security"><name>Security Considerations</name>
      <!-- All drafts are required to have a security considerations section. See RFC 3552 for a guide. -->
      <t>This document should not affect the security of the Internet. [CHECK]</t>
    </section>
    
    <!-- NOTE: The Acknowledgements and Contributors sections are at the end of this template -->
  </middle>

  <back>
    <references><name>References</name>
      <references><name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3339.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml"/>
      </references>
      <references><name>Informative References</name>
        <reference anchor="JSON-ND" target="https://github.com/glenkleidon/JSON-ND"><front>
          <title>JSON-ND</title>
          <author initials="G" surname="Kleidon"></author>
          <date year="2020"/>
        </front></reference>      
      </references>
    </references>
    
    <section>
      <name>Appendix 1 [REPLACE/DELETE]</name>
      <t>This becomes an Appendix [REPLACE]</t>
    </section>

    <section anchor="Acknowledgements" numbered="false"><name>Acknowledgements</name>
      <t>This template uses extracts from templates written by Pekka Savola, Elwyn Davies and 
        Henrik Levkowetz. [REPLACE]</t>
    </section>
    
    <section anchor="Contributors" numbered="false"><name>Contributors</name> 
      <t>Thanks to all of the contributors. [REPLACE]</t>
    </section>
    
 </back>
</rfc>
