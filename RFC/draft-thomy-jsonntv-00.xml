<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="rfc7991bis.rnc"?>  
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">]>
<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="info"
  docName="draft-thomy-jsonntv-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  version="0">
  <front>
    <title abbrev="JSON-NTV">JSON-NTV semantic format</title>
    <seriesInfo name="Internet-Draft" value="draft-thomy-jsonntv-00"/>
    <author fullname="Philippe THOMY" initials="P" role="editor" surname="THOMY">
      <organization>Loco-labs</organization>
      <address>
        <postal>
          <street>476 chemin du gaf de Famian</street>
          <city>BOLLENE</city>
          <code>84 500</code>
          <country>FR</country></postal>        
        <email>philippe@loco-labs.io</email>  
        <uri>https://github.com/loco-philippe/NTV/blob/main/README.md</uri>
      </address>
    </author> 
    <date year="2023"/>
    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>JSON SEMANTIC</keyword>
    <abstract>
      <t>This document describes a set of simple rules for unambiguously and concisely encoding semantic data into 
      JSON Data Interchange Format. These rules and framework, called JSON-NTV (JSON with 
      Named and Typed Values), relies on the rules defined in the.</t>
    </abstract>
  </front>
  &nbsp;
  <middle>
    <section><name>Introduction</name>
      <section><name>Presentation</name>
        <t>Today, the semantic level of shared data remains low. It is very often limited to the type of data defined 
        in the exchange formats (strings for CSV formats; numbers, strings, arrays and objects for JSON formats).</t>
        <t>JSON-NTV proposes to increase the semantic level of the JSON entities <xref target="RFC8259"/> 
        by adding two additional pieces of information to a JSON entity :<ul>
          <li><strong>name</strong>: interpretation of the value in human language or detailed information or link to external information,</li>
          <li><strong>type</strong>: interpretation of the value in a data standard (e.g. GeoJSON, datetime), in a data catalog or 
          in a software language.</li></ul>
        </t>
        <t>The NTV entity is thus a triplet with a mandatory element (value) and two additional elements (name, type). </t>
        <ul empty="true">
          <li><em>For example, Paris location can be represented by : </em><ul spacing="compact">
            <li><em>a name : "paris",</em></li>
            <li><em>a type : geoJSON Point coordinates <xref target="RFC7946"/>,</em></li>
            <li><em>a value : [2.3522, 48.8566]</em></li>
          </ul></li>
        </ul>
        <t>The easiest way to add that information into a JSON-value is to use a JSON-object with a single member using 
        the syntax JSON-ND <xref target="JSON-ND"/> for the first term of the member and the JSON-value for the second term of the member.</t>
        <ul empty="true">
          <li><em>The JSON value of the previous example is:</em><ul spacing="compact" empty="true">
            <li><em>{ "paris:point" : [2.3522, 48.8566] }</em></li>
          </ul></li>
        </ul>
        <t>With this approach, two NTV entities are defined :<ul>
          <li><strong>a primitive entity</strong> which is not composed of any other entity,</li>
          <li><strong>a structured entity</strong> which is an ordered sequence of NTV entities.</li></ul>
        as well as two JSON formats depending on the presence of the additional elements : <ul>
          <li><strong>simple format</strong> when name and type are not present</li>
          <li><strong>named format</strong> when name or type is present </li></ul></t>
        <ul empty="true">
          <li><em>Example (entity composed of two other primitive entities): </em><ul spacing="compact" empty="true">
            <li><em>{ "cities::point": [[2.3522, 48.8566], [4.8357, 45.7640]] } </em></li>
            <li><em>{"cities::point": {"paris":[2.3522, 48.8566], "lyon":[4.8357, 45.7640]}}</em></li>
          </ul></li>
        </ul>
        <t>A JSON-NTV generator produces a JSON-value from a NTV entity and vice versa a JSON-NTV parser transforms a 
        JSON-value into a NTV entity. </t>
        <t>The conversion between NTV entity and software object is not the subject of this note.</t>
      </section>
      <section><name>Key design features</name>
        <t>The format is focused on simplicity, lightness and web usage.</t>
        <t>The key features of this format are the following: <ul>
          <li><strong>JSON as the base format</strong><ul>
            <li>JSON is simple and readable as simple text</li>
            <li>JSON supports rich structure including nesting and basic types</li>
            <li>JSON is web-native and very widely used and supported</li>
            <li>JSON format has binary representation (i.e. CBOR format)</li></ul></li>
          <li><strong>high semantic level of data</strong><ul>
            <li>wide variety of data typing</li>
            <li>tree-like and customisable data typing </li></ul></li>
          <li><strong>compatibility with existing formats</strong><ul>
            <li>JSON data is a JSON-NTV data</li>
            <li>most of NTV types are existing types</li>
            <li>the defined types integrate the data catalogs (i.e.  schemaorg, darwincore)</li></ul></li>
          <li><strong>compatibility with any type of platform</strong><ul>
            <li>types and structures are independent of software and hardware platforms</li>
            <li>the NTV concept is applicable to all types of software and data</li></ul></li>
          <li><strong>reversibility</strong><ul>
            <li>the NTV entity coming from a Json is identical to the NTV entity from which the Json comes</li>
            <li>the Json representation of an NTV entity is the same as the Json value used to construct the NTV entity</li></ul></li>
        </ul></t>
      </section>     
      <section><name>Requirements Language</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.</t>
        <t>This document also uses the following terms:</t><dl newline="true">    
          <dt><strong>JsonType, JsonText, JsonName, JsonValue, JsonObject, JsonMember, JsonElement, JsonArray, JsonNumber,
           JsonString, JsonFalse, JsonNull, JsonTrue:</strong></dt>
          <dd>These terms are defined as type, text, name, value, object, member, element, array, number, string, false, 
          null, true in the JSON grammar.</dd>
          <dt><strong>JsonPrimitive:</strong></dt>
          <dd>A JsonNumber, JsonString, JsonFalse, JsonTrue or JsonNull.</dd>
          <dt><strong>JsonUnnamed:</strong></dt>
          <dd>A JSON-object without a single member.</dd>
          <dt><strong>JsonNamed:</strong></dt>
          <dd>A JSON-object with a single member.</dd>
          <dt><strong>NTVsingle, NTVlist:</strong></dt>
          <dd>NTVlist and NTVsingle entities can be abbreviated as:<ul>
                <li>NVsingle : entity with default NTVtype "json",</li>
                <li>NVlist : entity without NTVtype,</li>
                <li>TVsingle, TVlist : entity without NTVname,</li>
                <li>Vsingle, Vlist : NVsingle or NVlist without NTVname.</li></ul></dd>
        </dl>
      </section>
    </section>
    &nbsp;
    <section><name>NTV structure</name>
      <section><name>NTV layers</name>
        <t>Two structures are defined as shown in <xref target="NTVlayers-svg" format="default" sectionFormat="of" derivedContent="Figure 1"/>:</t><ul>
          <li>NTV is a triplet (NTVname, NTVtype, NTVvalue) that contains all the data needed to reconstruct the software object. 
          NTV is used to build the software object.</li>
          <li>JsonNTV is the JsonValue of the NTV entity. JsonNTV is used to build an interchangeable JsonText</li></ul>
        <figure anchor="NTVlayers-svg" align="left" suppress-title="false" pn="figure-1"><name>NTV layers</name><artset>      
          <artwork type="svg" name="https://www.rfc-editor.org/materials/format/svg/stream.svg">  
            <svg viewBox="0 0 500 100" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
            <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
            <g class="layer">
              <title>Layer 1</title>
              <rect fill="#ffffff" height="35.36" id="svg_1" stroke="#000000" transform="matrix(1 0 0 1 0 0)" width="63.29" x="32.53" y="30"/>
              <text fill="#000000" font-size="10" id="svg_2" stroke="#000000" stroke-width="0" text-anchor="middle" x="66.88" xml:space="preserve" y="50.07">JsonText</text>
              <rect fill="#ffffff" height="35.36" id="svg_4" stroke="#000000" transform="matrix(1 0 0 1 0 0)" width="63.79" x="157.13" y="29.98"/>
              <text fill="#000000" font-size="10" id="svg_3" stroke="#000000" stroke-width="0" text-anchor="middle" transform="matrix(0.98567 0 0 1 0.245089 0)" x="191.49" xml:space="preserve" y="50.05">JsonNTV</text>
              <rect fill="#ffffff" height="35.36" id="svg_8" stroke="#000000" width="63.29" x="401.77" y="30.12"/>
              <text fill="#000000" font-size="10" id="svg_7" stroke="#000000" stroke-width="0" text-anchor="middle" transform="matrix(1 0 0 1 0 0)" x="434.13" xml:space="preserve" y="49.69">native entity</text>
              <path d="m96.43,34.64l59.83,0" fill="#ffffff" id="svg_9" stroke="#000000"/>
              <path d="m146,32.14l-0.22,5.36l10.36,-2.51c-3.38,-0.95 -6.76,-1.9 -10.14,-2.85z" fill="#000000" id="svg_11" stroke="#000000"/>
              <rect fill="#ffffff" height="35.36" id="svg_6" stroke="#000000" transform="matrix(1 0 0 1 0 0)" width="63.79" x="277.27" y="29.9"/>
              <text fill="#000000" font-size="10" id="svg_5" stroke="#000000" stroke-width="0" text-anchor="middle" transform="matrix(1 0 0 1 0 0)" x="311.63" xml:space="preserve" y="49.97">NTV triplet</text>
              <path d="m341.92,35.9l59.5,0" fill="#ffffff" id="svg_12" stroke="#000000"/>
              <path d="m391.16,33.4l-0.22,5.36l10.36,-2.51c-3.38,-0.95 -6.76,-1.9 -10.14,-2.85z" fill="#000000" id="svg_10" stroke="#000000"/>
              <path d="m221.58,35.57l53.83,0" fill="#ffffff" id="svg_14" stroke="#000000"/>
              <path d="m265.16,33.07l-0.22,5.36l10.36,-2.51c-3.38,-0.95 -6.76,-1.9 -10.14,-2.85z" fill="#000000" id="svg_13" stroke="#000000"/>
              <path d="m96.73,57.76l59.83,0" fill="#ffffff" id="svg_17" stroke="#000000"/>
              <path d="m342.22,59.02l59.5,0" fill="#ffffff" id="svg_16" stroke="#000000"/>
              <path d="m221.88,58.69l53.83,0" fill="#ffffff" id="svg_15" stroke="#000000"/>
              <path d="m342.26,56.38l-0.22,5.36l10.36,-2.51c-3.38,-0.95 -6.76,-1.9 -10.14,-2.85z" fill="#000000" id="svg_18" stroke="#000000" transform="rotate(178.552 347.222 59.055)"/>
              <path d="m221.96,55.84l-0.22,5.36l10.36,-2.51c-3.38,-0.95 -6.76,-1.9 -10.14,-2.85z" fill="#000000" id="svg_19" stroke="#000000" transform="matrix(1 0 0 1 0 0) rotate(178.552 226.924 58.5164)"/>
              <path d="m106.62,60.07l0.08,-5.36l-10.29,2.77c3.4,0.86 6.81,1.73 10.21,2.59z" fill="#000000" id="svg_20" stroke="#000000"/>
              <text fill="#000000" font-size="8" id="svg_24" stroke="#000000" stroke-width="0" text-anchor="middle" x="121.5" xml:space="preserve" y="31.72">JSON load</text>
              <text fill="#000000" font-size="8" id="svg_25" stroke="#000000" stroke-width="0" text-anchor="middle" x="127.78" xml:space="preserve" y="66.39">JSON dump</text>
              <text fill="#000000" font-size="8" id="svg_27" stroke="#000000" stroke-width="0" text-anchor="middle" transform="matrix(1 0 0 1 0 0)" x="245.3" xml:space="preserve" y="32.39">NTV load</text>
              <text fill="#000000" font-size="8" id="svg_26" stroke="#000000" stroke-width="0" text-anchor="middle" x="251.58" xml:space="preserve" y="67.05">NTV dump</text>
              <text fill="#000000" font-size="8" id="svg_29" stroke="#000000" stroke-width="0" text-anchor="middle" transform="matrix(1 0 0 1 0 0)" x="368.64" xml:space="preserve" y="33.06">to_obj</text>
              <text fill="#000000" font-size="8" id="svg_28" stroke="#000000" stroke-width="0" text-anchor="middle" x="374.91" xml:space="preserve" y="67.72">from_obj</text>
            </g>
            </svg>
          </artwork>
          <artwork type="ascii-art" name="box.txt">
            <![CDATA[
+--------+ JSON load +-------+ NTV load +-------+  to_obj  +------+                                                    
|        |---------->|       |--------->|  NTV  |--------->|native|                                                    
|JsonText|           |JsonNTV|          |triplet|          |entity|                                                    
|        |<----------|       |<---------|       |<---------|      |                                                    
+--------+ JSON dump +-------+ NTV dump +-------+ from_obj +------+                                                              
            ]]>
          </artwork>
        </artset></figure>
        <t><em>Example:</em></t><ul>
          <li><em>Object layer</em><ul empty="true">
            <li>new_year_2022 = datetime.date(2022, 01, 01) <em>  is a Python variable "new_year_2022" corresponding to a datetime object</em></li></ul></li>
          <li><em>NTV layer</em><ul empty="true">
            <li>("new_year_2022", "date", "2022-01-01") <em>  is a triplet</em></li></ul></li>
          <li><em>JsonNTV layer</em><ul empty="true">
            <li>{ "new_year_2022:date" : "2022-01-01" }<em>  is a JsonValue</em></li></ul></li>
          <li><em>JsonText layer</em><ul empty="true">
            <li>'{"new_year_2022:date":"2022-01-01"}'<em>  is a string</em></li></ul></li></ul>          
      </section>
      <section><name>NTV entities</name>
        <t>Two categories of entities (one primitive and one structured) are defined:<ul>
          <li>NTVsingle for the primitive entity,</li>
          <li>NTVlist for an ordered sequence of NTV entities</li></ul></t>
        <t>Entities are defined in <xref target="NTVentities-abnf" format="default" sectionFormat="of" derivedContent="Figure 2"/>, 
        which uses ABNF from <xref target="RFC5234"/>.</t>
        <figure anchor="NTVentities-abnf" align="left" suppress-title="false" pn="figure-2">
          <name>NTV entities - ABNF</name>
          <sourcecode type="abnf" markers="false">
  ; notation:
  ;   "Object(" *param ")" represent an Object defined 
  ;   by a list of parameters (param)
  
  ;   JsonArray(*param) represent a JsonArray as defined 
  ;   in the Json grammar, *param is a list of JsonElement
  ;   JsonObject(*param) represent a JsonObject as defined 
  ;   in the Json grammar, *param is a list of JsonMember
  ;   JsonValue represent a JsonValue as defined 
  ;   in the Json grammar

  NTVentity = NTVsingle / NTVlist
  
  NTVsingle = "NTVsingle(" NTVsingleValue  NTVname  NTVsingleType ")"
  NTVsingleType  = NTVtype 
  NTVsingleValue = JsonValue

  NTVlist   = "NTVlist(" NTVlistValue  NTVname  NTVlistType ")"
  NTVlistType    = NTVtype / Namespace
  NTVlistValue   = *NTVentity
  
  NTVname        = string
  JsonValue      = string

  string   = DQUOTE *CHAR DQUOTE
  DQUOTE   = %x22          ; " double quote
  CHAR     = %x01-7F

          </sourcecode>
        </figure>
        <section><name>NTVsingle</name>
          <t>The NTVvalue (NTVsingleValue) is the JSON representation of the NTV entity (JsonValue).</t>
          <t>The NTVtype (NTVsingleType) defines the type of entity and the conversion rules between the NTV entity and the NTVvalue. 
          The default value is the "json" type.</t>
          <t>The NTVname is a string</t>
          <t><strong>In other words, any entity that has on the one hand a function of encoding it into a json value and 
          on the other hand a function of creating from a json value can be taken into account.
          This approach is very general because the majority of computer objects are defined by a list of parameters 
          (e.g. *args in python) and/or a list of key/values (e.g. **kwargs in python) 
          which simply translate into a JSON-Array or a JSON-Object.</strong></t>
        </section>
        <section><name>NTVlist</name>
          <t>The NTVvalue (NTVlistValue) is the list of included NTV entities.</t>
          <t>The NTVtype (NTVlistType) is a Namespace or a default NTVtype to apply to the NTV entities included. 
          This NTVtype avoids having to include a type (if default NTVtype) 
          or reduce the length (if Namespace) in the JSON representation of the included NTV entities. The default value is "None".</t>
          <t>The NTVname is a string.</t><ul empty="true">
            <li><em>Example of equivalent JSON representations:</em><ul spacing="compact" empty="true">
              <li><em>where NTVtype is None for the NTVlist</em><ul spacing="compact" empty="true">
                <li><em>[ { ":point" : [2.3522, 48.8566]}, {":point" : [4.8357, 45.7640]} ] </em></li>
              </ul></li>
              <li><em>where NTVtype is "point" for the NTVlist</em><ul spacing="compact" empty="true">
                <li><em>{ ":point" : [ [2.3522, 48.8566], [4.8357, 45.7640] ] }</em></li>
              </ul></li>
            </ul></li>
            <li><em>If JSON-value is { "::dat" : ["2022-01-28T18-23-54", {":point": [1.1, 2.2] ] } }, 
            the parsers deduce that the first NTVvalue has a  "dat" NTVtype and the second a "point" NTVtype.</em></li>
          </ul>
        </section>
      </section>
      <section><name>NTVtype</name>
        <t>NTVtype and associated Namespace  are defined in 
        <xref target="NTVtype-abnf" format="default" sectionFormat="of" derivedContent="Figure 3"/>, 
        which uses ABNF from <xref target="RFC5234"/>.</t>
        <figure anchor="NTVtype-abnf" align="left" suppress-title="false" pn="figure-3">
          <name>NTVtype - ABNF</name>
          <sourcecode type="abnf" markers="false">
; Namespace and NtvType

Namespace       = "Namespace(" NamespaceName NamespaceParent ")" 
NamespaceParent = Namespace  ; Namespace is nested
NamespaceName   = [ ["$"] string "." ] 
JsonNamespace   = JsonNamespaceParent NamespaceName
JsonNamespaceParent = JsonNamespace

NTVtype     = "NTVtype(" NTVtypeName NamespaceParent [NTVtypeGen] ")"
NTVtypeGen  = NTVtype
NTVtypeName = ["$"] string
JsonNTVtype = JsonNamespaceParent NTVtypeName  

          </sourcecode>
        </figure>
        <t>A NTVtype is defined by a name (NTVtypeName) and a Namespace parent (NamespaceParent). 
        The NTVtype is unique in the Namespace parent.</t>
        <t>NTVtype and the rules to encode or decode NTVvalues MUST be understood by data producers and data consumers.</t>
        <t>So NTVtype and rules associated have to be defined in a specification shared by a large community.</t>
        <t>On the other hand, it must be possible for everyone to share data according to their own data structure.</t>
        <t>There are therefore two categories of data: <ul>
          <li>custom NTVtype (and Namespace) which can be created by anyone without control,</li>
          <li>shared NTVtype (and Namespace) that are defined and used in a single, shared repository.</li></ul></t>
        <t>The corresponding rules are as follows:<ul>
          <li>NTVtype (or Namespace) whose name begins with '$' is of type 'custom'</li>
          <li>NTVtype (or Namespace) included in a Namespace of type 'custom' is also of type 'custom'</li>
          <li>Each 'shared' Namespace or NTVtype is uniquely managed.</li></ul></t>
        <t><em>Example:</em> <ul empty="true">
          <li><em>If "fr." is a Namespace attached to the global Namespace and containing the Namespace 'BAN.' and the NTVtype 'dep', then:</em> <ul>
            <li><em>"fr.dep" is a shared NTVtype,</em></li>
            <li><em>"fr.$test" is a custom NTVtype,</em></li>
            <li><em>"fr.$example.one" is a custom NTVtype</em></li>
            <li><em>"fr.BAN.$test" is a custom NTVtype</em></li></ul>
        </li></ul></t>
        <t>A Namespace is included in a Namespace parent (NamespaceParent) and may contain Namespace child.</t>
        <t>A Namespace is represented by a string followed by a point (NamespaceName). 
        The global Namespace (root node in the Namespace tree) is represented by an empty string and its NamespaceParent is None. 
        The Namespace representations are added to the value of an NTVtype to have an absolute representation of an NTVtype (JsonNTVtype).</t>
        <t><em>Example for an absolute representation of an NTVtype defined in two nested Namespace in the global Namespace:</em> <ul empty="true">
          <li><em>"ns1.ns2.type" </em> </li>
          <li><em> where:</em> <ul empty="true">
            <li><em>ns1. is a Namespace defined in the global Namespace,</em> </li>
            <li><em>ns2. is a Namespace defined in the ns1. Namespace,</em> </li>
            <li><em>type is a NTVtype defined in the ns2. Namespace</em> </li></ul>
        </li></ul></t>
        <t>Three categories of NTVtype are defined (None, Simple, Generic).<ul>
          <li>The "None" NTVtype is used with NTVlist to indicate the absence of a default Type.</li>
          <li>If NTVtype is Simple, the rules associated with the NTVtype are used  for the conversion between an entity and a NTVvalue.</li>
          <li>The Generic NTVtype (NTVtypeGen) is equivalent to a set of Simple NTVtype. 
          This indicates that parsers can use an associated simple NTV type to decode the JsonNTVvalue.</li></ul></t>
        <t><em>Example:</em> <ul empty="true">
          <li><em>"dat" is the generic NTVtype for "datetime" and "timeposix"</em> </li>
          <li><em> If a JSONvalue is { "::dat" : ["2022-01-28T18-23-54", 123456.78] }, the parser deduce that the NTVvalue of included entities 
          has a NTVtype with a "dat" NTVtypeGen. The parser of included NTV entities deduces that the first object has an equivalent "datetime" 
          NTVtype and the second an equivalent "timeposix" NTVtype.</em></li>
        </ul></t>       
        <t>This structuring of type makes it possible to reference any type of data that has a JSON representation and to consolidate 
        all the shared data structures within the same tree of types.</t>
      </section>      
    </section>
    &nbsp;
    <section><name>JsonNTV</name>
      <section><name>JsonNTV format</name>
        <t>The JsonNTV format is the JsonValue representation of an NTV entity as defined in 
        <xref target="JsonNTV-abnf" format="default" sectionFormat="of" derivedContent="Figure 4"/>, 
        which uses ABNF from <xref target="RFC5234"/>.</t>
        <figure anchor="JsonNTV-abnf" align="left" suppress-title="false" pn="figure-4">
          <name>JsonNTV - ABNF</name>
          <sourcecode type="abnf" markers="false">
; JsonValue representation of NTV entities

JsonNTV        = JsonNTVnamed / JsonNTVsimple

JsonNTVnamed   = "JsonObject(" JsonNTVname ":" JsonNTVvalue ")" 
JsonNTVsimple  = JsonNTVvalue

JsonNTVname    = NTVname / (NTVname JsonType) / JsonType
JsonType       = [singleSep [JsonNTVtype]] / [listSep [JsonNTVtype]]  

singleSep   = ":"      ; NTVsingle separator 
listSep     = "::"     ; NTVlist separator
          </sourcecode>
        </figure>
        <t>The JsonNTV format is built with the NTVname, NTVvalue and the JsonNTVtype.</t>
        <t>Two JsonNTV formats are defined:<ul>
          <li>named format (if NTVname or JsonType is not an empty string): <ul empty="true">
            <li><em>{ JsonNTVname : JsonNTVvalue }</em></li></ul></li>
          <li>simple format (if NTVname and JsonType are empty string): <ul empty="true">
            <li><em>JsonNTVvalue</em></li></ul></li>
        </ul></t>
        <t>This format allows full compatibility with existing JSON structures:<ul>
          <li>a JsonNumber, JsonString, JsonNull or JsonBoolean is the representation of a Vsingle entity,</li>
          <li>a JsonObject with a single member is the representation of an NVsingle or TVsingle entity,</li>
          <li>a JsonArray is the representation of a Vlist entity,</li>
          <li>a JsonObject without a single member is the representation of a Vlist entity composed with unnamed entities.</li>
        </ul></t>
        <t><em>Note :</em><ul>
          <li><em>JsonNTV : 21, { ":" : 21 } and { ":json" : 21 } represent the same Vsingle entity,</em></li>
          <li><em>a NTVlist with a single included entity has a JsonNTVname with a pair of colons e.g. { "::" : { "age" : 21 } }</em></li>
        </ul></t>
      </section>
      <section><name>JsonNTVname</name>
        <t><strong>JsonNTVname</strong></t><ul empty="true">
          <li>JsonNTVname is the concatenation of NTVname and JsonType.</li>
          <li>If the JsonNTVname contains one colon, the entity is a NTV-single.</li>
          <li>If the JsonNTVname contains two adjacent colons, the entity is an NTV-list.</li></ul>
        <t><strong>JsonType</strong></t><ul empty="true">
          <li>The JsonType is composed with the separator singleSep or listSep and the JsonNTVtype.</li>
          <li>For NTVsingle entities:<ul>
            <li>The JsonType is identical to the singleSep joined with JsonNTVtype if JsonNTVtype is not "json".</li>
            <li>If JsonNTVtype is "json" and JsonNTVvalue is not a JsonArray and not a JsonObject with not a single member, the JsonType is empty.</li>
            <li>If JsonNTVtype is "json" and JsonNTVvalue is a JsonArray or a JsonObject with not a single member, the JsonType is ":".</li></ul></li>
          <li>For NTVlist entities:<ul>
            <li>The JsonType is identical to the listSep joined with JsonNTVtype if JsonNTVtype is not "json".</li>
            <li>If JsonNTVtype is "json" and JsonNTVvalue is not a JsonArray and not a JsonObject with not a single member, the JsonType is "::".</li>
            <li>If JsonNTVtype is "json" and JsonNTVvalue is a JsonArray or a JsonObject with not a single member, the JsonType is empty.</li></ul></li>
          <li>For NTV entities included in another entity, the JsonType MAY be set to :<ul>
            <li>The empty string if the NTVtype of the structured NTV entity is identical to the NTVtype of the NTV entity,</li>
            <li>relative NTVtype if the NTVtype of the structured NTV entity is a Namespace shared with the NTVtype of the NTV entity.</li></ul></li></ul>
      </section>
      <section><name>JsonNTVvalue</name>
        <t>The JsonNTVvalue is the JsonValue representation of NTVvalue as defined in 
        <xref target="JsonNTVvalue-abnf" format="default" sectionFormat="of" derivedContent="Figure 5"/>, 
        which uses ABNF from <xref target="RFC5234"/>.</t>
        <figure anchor="JsonNTVvalue-abnf" align="left" suppress-title="false" pn="figure-5">
          <name>JsonNTVvalue - ABNF</name>
          <sourcecode type="abnf" markers="false">
; Json representation of NTVvalue

JsonNTVvalue       = JsonNTVsingleValue / JsonNTVlistValue

JsonNTVsingleValue = NTVsingleValue
JsonNTVlistValue   = JsonArrayValue / JsonObjectValue

JsonArrayValue     = "JsonArray(" *JsonNTV ")"
JsonObjectValue   = "JsonObject(" *(JsonNTVname ":" JsonNTVvalue) ")"

          </sourcecode>
        </figure>
        <t>For a NTVsingle, JsonNTVvalue is the NTVvalue.</t>
        <t>For a NTVlist, JsonNTValue has two representations:<ul>
          <li>a JsonArray where JsonElements are the JsonNTV of included NTV entities,</li>
          <li>a JsonObject where the JsonMembers are the JsonMembers of the JsonNTV of included NTV entities.</li></ul></t>
        <t><em>Note:</em><ul empty="true">
          <li><em>The JsonObject option is available only if all the NTV entities included have a JsonNTVname and 
          all the JsonNTVname are different (e.g. {":point" : [2.3522, 48.8566], ":point" : [4.8357, 45.7640]} 
          is not a valid  JSON-value)</em></li></ul></t>
      </section>
    </section>
    &nbsp;
    <section><name>examples</name>
      <t>Examples of JsonNTV representation of NTV entities:</t>
      <t><strong>Vsingle :</strong></t><ul empty="true">
        <li><em>"lyon"</em></li>
        <li><em>52.5</em></li>
        <li><em>{ ":" : [4.8357, 45.7640] }</em></li></ul>
      <t><strong>NVsingle : </strong></t><ul empty="true">
        <li><em>{ "city" : "paris" }</em></li>
        <li><em>{ "paris:" : [4.8357, 45.7640] }</em></li></ul>
      <t><strong>TVsingle: </strong></t><ul empty="true">
        <li><em>{ ":point" : [4.8357, 45.7640] }</em></li></ul>
      <t><strong>NTVsingle: </strong></t><ul empty="true">
        <li><em>{ "paris:point" : [2.3522, 48.8566] }</em></li>
        <li><em>{ "paris:ntv" : { "coordinate:point" : [4.8357, 45.7640] } }</em></li></ul>
      <t><strong>Vlist (composed with JsonArray): </strong></t><ul empty="true">
        <li><em>[4, 45]</em></li>
        <li><em>["paris"]</em></li>
        <li><em>[ [2.3522, 48.8566], {"lyon" : [4.8357, 45.7640]} ]</em></li>
        <li><em>[ { ":point" : [2.3522, 48.8566]}, {":point" : [4.8357, 45.7640]} ]</em></li>
        <li><em>[]</em></li></ul>
      <t><strong>Vlist (composed with JsonObject) :</strong></t><ul empty="true">
        <li><em>{ "name": "white", "firstname":"walter", "surname":"heisenberg" }</em></li>
        <li><em>{ "paris:point" : [2.3522, 48.8566] , "lyon" : "france"}</em></li>
        <li><em>{ "paris" : [2.3522, 48.8566], "" : [4.8357, 45.7640]}</em></li>
        <li><em>{ }</em></li></ul>
      <t><strong>NVlist : </strong></t><ul empty="true">
        <li><em>{ "simple list": [4, 45.7]}</em></li>
        <li><em>{ "cities": [{":point": [2.3522, 48.8566]}, {":point": [4.8357, 45.7640]}]}</em></li></ul>
      <t><strong>TVlist : </strong></t><ul empty="true">
        <li><em>{ "::point": [[2.3522, 48.8566], {"lyon" : [4.8357, 45.7640]} ] }</em></li>
        <li><em>{ "::dat": [ "2022-01-28T18-23-54Z", "2022-01-28", 1234.78 ] }</em></li></ul>
      <t><strong>NTVlist : </strong></t><ul empty="true">
        <li><em>{ "cities::point": [[2.3522, 48.8566], {"lyon": [4.8357, 45.7640]}] }</em></li>
        <li><em>{ "generic date::dat": [ "2022-01-28T18-23-54Z", "2022-01-28", 1234.78]}</em></li>
        <li><em>{ "various::point": [ [2.3522, 48.8566], { ":date": "2022-01-28"}</em></li>
        <li><em>{"json": 25 }, { "another NTVlist":: [ 1,2,3]}]}</em></li></ul>
      <t><strong>NTVlist and NVlist (composed with JsonObject) :</strong></t><ul empty="true">
        <li><em>{ "cities::point": { "paris": [2.352, 48.856], "lyon": [4.835, 45.764]}}</em></li>
        <li><em>{ "cities": {"paris:point": [2.3522, 48.8566] , "lyon": "france"}}</em></li>
        <li><em>{ "city::": {"paris": [2.3522, 48.8566] } }</em></li></ul>
    </section>
    &nbsp;
    <section><name>Parsing a JsonValue</name>
      <t>A first decoding step identifies the following objects:</t><ul empty='true'>
        <li>JsonNTVvalue, NTVname (if present), separator (if present), JsonNTVtype (if present).</li></ul>
      <t>The tables below present the rules for identifying angle NTV entity.</t> 
      <table anchor="table1" align="left" pn="table-1"><name>Decoding JsonValue</name>
        <thead>
          <tr><th align="left" colspan="1" rowspan="1">JsonValue</th>
              <th align="left" colspan="1" rowspan="1">NTV entity</th></tr>
        </thead><tbody>
          <tr><td align="left" colspan="1" rowspan="1">JsonPrimitive</td>
              <td align="left" colspan="1" rowspan="1">Vsingle</td></tr>
          <tr><td align="left" colspan="1" rowspan="1">JsonUnnamed</td>
              <td align="left" colspan="1" rowspan="1">Vlist</td></tr>
          <tr><td align="left" colspan="1" rowspan="1">JsonArray</td>
              <td align="left" colspan="1" rowspan="1">Vlist</td></tr>
          <tr><td align="left" colspan="1" rowspan="1">JsonNamed</td>
              <td align="left" colspan="1" rowspan="1">see <xref target="table2"/></td></tr>
        </tbody></table>
      <table anchor="table2" align="left" pn="table-2"><name>Decoding JsonNTVvalue</name>
        <thead>
          <tr><th align="left" colspan="1" rowspan="1">Separator</th>
              <th align="left" colspan="1" rowspan="1">JsonNTVvalue</th>
              <th align="left" colspan="1" rowspan="1">NTV entity</th></tr>
        </thead><tbody>
          <tr><td align="left" colspan="1" rowspan="1">None</td>
              <td align="left" colspan="1" rowspan="1">JsonPrimitive</td>
              <td align="left" colspan="1" rowspan="1">NVsingle</td></tr>
          <tr><td align="left" colspan="1" rowspan="1">None</td>
              <td align="left" colspan="1" rowspan="1">JsonNamed</td>
              <td align="left" colspan="1" rowspan="1">NVsingle</td></tr>
          <tr><td align="left" colspan="1" rowspan="1">None</td>
              <td align="left" colspan="1" rowspan="1">JsonUnnamed</td>
              <td align="left" colspan="1" rowspan="1">NVlist</td></tr>                
          <tr><td align="left" colspan="1" rowspan="1">None</td>
              <td align="left" colspan="1" rowspan="1">JsonArray</td>
              <td align="left" colspan="1" rowspan="1">NVlist</td></tr>
          <tr><td align="left" colspan="1" rowspan="1">":"</td>
              <td align="left" colspan="1" rowspan="1">JsonValue</td>
              <td align="left" colspan="1" rowspan="1">TVsingle or NTVSingle</td></tr>
          <tr><td align="left" colspan="1" rowspan="1">"::"</td>
              <td align="left" colspan="1" rowspan="1">JsonUnnamed</td>
              <td align="left" colspan="1" rowspan="1">NVlist or TVlist or NTVlist</td></tr>
          <tr><td align="left" colspan="1" rowspan="1">"::"</td>
              <td align="left" colspan="1" rowspan="1">JsonArray</td>
              <td align="left" colspan="1" rowspan="1">NVlist or TVlist or NTVlist</td></tr>                                                
        </tbody></table>
      <t>The NTVvalue of NTVsingle is the JsonNTVvalue.</t>
      <t>The NTVvalue of NTVlist is build by decoding data included in JsonNTVvalue.</t>
      <t>For NTV entities not included in a NTVlist, the NTVtype is built with:</t><ul>
        <li>"json" JsonNTVtype if JsonNTVtype is None and if the NTV entity is a NTVsingle,</li>
        <li>the NTVtype build with the JsonNTVType.</li></ul>
      <t>For NTV entities included in a NTVlist, the NTVtype is built with : </t><ul>
        <li>the JsonNTVtype if it is an absolute NTVtype and if the entity is a NTVsingle,</li>
        <li>the concatenation of the JsonNTVtype of the NTVlist and the JsonNTVtype (if it is a relative NTVtype),</li>
        <li>the JsonNTVtype of the NTVlist if the JsonNTVtype is None.</li></ul>
      <t>If the resulting NTVtype is inconsistent, the NTVtype is set to None.</t>
      <t>The <xref target="JSON-NTV"/> repository gives some examples of NTV usage.</t>
    </section>
    &nbsp;
    <section><name>NTV extended structure</name>
      <t>The NTVvalue of NTV entities are JsonValue. In the NTV extended structure, NTVvalue can be every kind of data.</t>
      <t>With this structure, the NTV representation is a "json like" data where:</t><ul>
        <li>JsonNTVvalue is always NTVvalue,</li>
        <li>JsonNTVtype is optional (if NTVtype can be deduced from the NTVvalue),</li>
        <li>JsonNTVname is optional (if NTVname can be deduced from the NTVvalue).</li></ul>

      <t><em>Examples of NTV extended representation:</em></t><ul empty="true">
        <li><ul empty="true"><li><t><em>{ "date object" : [ datetime.date(2022, 1, 18), datetime.date(2023, 1, 12) ] }</em></t></li></ul></li>
        <li><em>this "json like" structure can be converted in JsonNTV format:</em></li>
        <li><ul empty="true"><li><t><em>{ "date object::date" : [ "2022-01-18", "2023-01-12" ] }</em></t></li></ul></li></ul>
    </section>
    &nbsp;
    <section anchor="IANA"><name>IANA Considerations</name>
    <!-- All drafts are required to have an IANA considerations section. See RFC 8126 for a guide.-->
      <t>The MIME media type for JSON text sequences is "application/json-ntv" :<ul>
        <li>Type name: application</li>
        <li>Subtype name: json-seq</li>
        <li>Required parameters: N/A</li>
        <li>Optional parameters: N/A</li>
        <li>Encoding considerations: binary (The standard encoding format is UTF-8 as per standard practice in application/json mimetype)</li>
        <li>Security considerations: Described herein</li>
        <li>Published specification: This document.</li>
        <li>Interoperability considerations: The media type is intended to interoperate across as many systems and applications as possible.</li>
        <li>Applications that use this media type: Any application needing to interoperate with another system may use this message syntax.
        As JsonNTV is syntactically identical to JSON syntax, any application currently using JSON syntax may alternatively use JsonNTV.</li>
        <li>Fragment identifier considerations: N/A</li>
        <li>Additional information:<ul>
            <li>Deprecated alias names for this type: N/A</li>
            <li>Magic number(s): N/A</li>
            <li>File extension(s): N/A</li>
            <li>Macintosh file type code(s): N/A</li></ul></li>
        <li>Person and email address to contact: philippe@loco-labs.io</li>
        <li>Intended usage: COMMON</li>
        <li>Author: Philippe Thomy (philippe@loco-labs.io)</li>
        <li>Change controller: IETF</li></ul></t>
    </section>
    <section anchor="Security"><name>Security Considerations</name>
      <!-- All drafts are required to have a security considerations section. See RFC 3552 for a guide. -->
      <t>The format used for NTV data exchanges is the JSON format. 
      So, all the security considerations of <xref target="RFC8259"/> apply.</t>
      <t>The NTV structure provides no cryptographic integrity protection of any kind.</t>
    </section>
  </middle>
  &nbsp;
  <back>
    <references><name>References</name>
      <references><name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7946.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml"/>
      </references>
      <references><name>Informative References</name>
        <reference anchor="JSON-ND" target="https://github.com/glenkleidon/JSON-ND"><front>
          <title>JSON-ND</title>
          <author initials="G" surname="Kleidon"></author>
          <date year="2020"/>
        </front></reference>
        <reference anchor="JSON-NTV" target="https://github.com/loco-philippe/NTV#readme"><front>
          <title>JSON-NTV</title>
          <author initials="P" surname="Thomy"></author>
          <date year="2022"/>
        </front></reference>      
      </references>
    </references>
    &nbsp;
    <section><name>Appendix 1 - Global NTVtype</name>
      <t>The structure of NTVtype by Namespace makes it possible to have types corresponding to recognized standards at the global level.</t>
      <t>A Global NTVtype is a NTVtype defined in the Global Namespace.</t>
      <t>The Global NTVtype are listed below (to be completed).</t>
      <section><name>Json NTVtype</name>
        <t>Json types have a generic Type : json</t>
        <table anchor="table3" align="left" pn="table-3"><name>"json" NTVtype</name>
          <thead>
            <tr><th>NTVtype (generic)</th><th>NTVvalue</th><th>example NTVvalue</th></tr>
          </thead><tbody>
            <tr><td>json</td><td>JsonValue <xref target="RFC8259"/></td><td>{"value": [1, 2] }</td></tr>
            <tr><td align="left" colspan="1" rowspan="1">json</td>
                <td align="left" colspan="1" rowspan="1">JsonValue <xref target="RFC8259"/></td>
                <td align="left" colspan="1" rowspan="1">{"value": [1, 2] }</td></tr>
        </tbody></table>
        



      </section>
    </section>
    <section anchor="Acknowledgements" numbered="false"><name>Acknowledgements</name>
      <t>TBD</t>
    </section>
    <section anchor="Contributors" numbered="false"><name>Contributors</name> 
      <t>Thanks to all of the contributors. -REPLACE-</t>
    </section>
 </back>
</rfc>
