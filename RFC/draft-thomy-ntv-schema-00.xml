<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="rfc7991bis.rnc"?>
<!DOCTYPE rfc [<!ENTITY nbsp    "&#160;"><!ENTITY zwsp   "&#8203;"><!ENTITY nbhy   "&#8209;"><!ENTITY wj     "&#8288;">]>
<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="info"
  docName="draft-thomy-ntv-schema-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  version="2">

  <front>
    <title>NTV - JSON Schema extension to NTV data</title>
    <seriesInfo name="Internet-Draft" value="draft-thomy-ntv-schema-00"/>
    <author fullname="Philippe THOMY" initials="P." surname="THOMY">
      <organization>Loco-labs</organization>
      <address>
        <postal>
          <street>476 chemin du gaf de Famian</street>
          <city>BOLLENE</city>
          <code>84 500</code>
          <country>FR</country>
        </postal>        
        <email>philippe@loco-labs.io</email>  
        <uri>https://github.com/loco-philippe/NTV/blob/main/README.md</uri>
      </address>
    </author> 
    <date year="2024" month="02" day="10"/>
    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>JSON</keyword>
    <keyword>schema</keyword>
    <keyword>semantic</keyword>
    <keyword>data interchange format</keyword>
    <abstract pn="section-abstract">
      <t>The NTV format is an extension of the JSON format integrating a semantic dimension through the notion of type. 
      This format remains compatible with the current JSON format but it is relevant to examine its compatibility and its impacts with data schemas.
      This document provides some answers to this question and presents some of the possible developments based mainly on the example of JSON Schema 
      and additionally on the example of OpenAPI.</t>
    </abstract>
    <note>
      <name>Note to Readers</name>
        <t>This document is a working document and not a specification document.
        The developments and principles presented have been validated by a Python implementation based on the jsonschema module 
        (<eref target="https://github.com/loco-philippe/NTV/blob/main/json_ntv/ntv_schema.py">https://github.com/loco-philippe/NTV/blob/main/json_ntv/ntv_schema.py</eref>)</t>
    </note>
  </front>
  &nbsp;
  <middle>
    <section><name>Introduction</name>
        <t>JSON format primitives include a low semantic level (string, number, boolean, null).</t>
        <t>To represent information with a high semantic level two mechanisms are used:</t><ul>
            <li>Data structuring using JSON structure entities (json-array and json-object).</li>
            <li>Coding/decoding of these structures.</li></ul>
        <t>JSON data schemas are a particular form of representation of encoding/decoding.</t>
        <t>The analysis and validation by prototyping of the developments presented in this document show us that:</t><ul>
            <li>The principles on which JSON Schema is built can be transposed to NTV instances.</li>
            <li>The majority of existing JSON Schema functions are applicable to NTV instances.</li>
            <li>Using schemas for NTV instances allows to:<ul>
                <li>Extend the functionalities and uses.</li>
                <li>Simplify the schemas.</li>
                <li>Deport certain control tasks (eg type and format) to the NTV structure.</li></ul></li></ul>
    </section>
    <section><name>Presentation</name>
        <section><name>NTV</name>
            <t>The NTV structure consists of representing data with three attributes: a name (NTVname: json-string), a value (NTVvalue: json-value) and a type (NTVtype: json-string).</t>
            <t>The json representation is obtained by grouping the NTVname and NTVtype (JsonNTVname) and associating it with NTVvalue in a key/value form. e.g.</t>
                <sourcecode type="json">{"firstname:string": "peter"}</sourcecode>
            <t>NTV distinguishes between two types of entity:</t><ul>
                <li>NTVsingle where the NTVvalue is a JsonValue</li>
                <li>NTVlist where the NTVvalue is an ordered list of NTV entities</li></ul>
            <t>The NTVtype can be simple (eg 'int') or structured from nested namespaces (eg 'org.Person.givenName' for a type defined by Schema.org).</t>
            <t>An NTV structure is therefore a tree composed of inner-nodes (NTVlist) and leaf-nodes (NTVsingle). 
            Each node of this structure can be uniquely identified by a name (JsonNTVname or NTVname if it is unique) or by its index in the parent node. 
            This identification can be carried out by an NTVpointer identical to the JSONpointer in the majority of cases.</t>
            <t>For example,</t>
                <sourcecode type="json">{"family": "doe", "childrens age": [15, 24, 12] }</sourcecode>
            <t>is a JSON representation of the NTV structure defined in <xref target="table1"/>.</t>
            <table anchor="table1" align="left" pn="table-1"><name>NTV structure</name><thead>
                <tr><th>node</th><th>NTVname</th><th>NTVtype</th><th>NTVvalue</th><th>ntv-pointer</th></tr></thead><tbody>
                <tr><td>NTVlist</td><td>None</td><td>None</td><td>list of 2 nodes</td><td>empty string</td></tr>
                <tr><td>NTVsingle</td><td>family</td><td>json</td><td>doe</td><td>/family</td></tr>
                <tr><td>NTVlist</td><td>childrens age</td><td>None</td><td>list of 3 nodes</td><td>/childrens age</td></tr>
                <tr><td>NTVsingle</td><td>None</td><td>json</td><td>15</td><td>/childrens age/0</td></tr>
                <tr><td>NTVsingle</td><td>None</td><td>json</td><td>24</td><td>/childrens age/1</td></tr>
                <tr><td>NTVsingle</td><td>None</td><td>json</td><td>12</td><td>/childrens age/2</td></tr>
                </tbody></table>
            <t><em>Note:</em></t><ul empty="true">
                <li><em>Any JSON structure corresponds to an NTV structure with a default NTVtype (None for NTVlist and "json" for NTVsingle).</em></li></ul>
        </section>
        <section><name>JSON Schema</name>
            <t>JSON Schema is one of the best-known tools for structuring JSON data. It proposes :</t><ul>
                <li>A tool for describing constraints to be respected (schema).</li>
                <li>A tool for validating JSON data for a defined schema.</li></ul>
            <t>A schema is a JsonObject (or a boolean) where JsonObject properties that are applied to the JSON data to control (instance) are called keywords.</t>
            <t>A schema can be represented by a simple association between an instance and a set of constraints to respect:</t><ul>
                <li>The instance is identified as a json-pointer (a name associated with the keyword 'properties' when it concerns data included in a JsonObject 
                or an index associated with the keyword 'prefixItems' when it is a JsonArray).</li>
                <li>The set of constraints is expressed as keywords associated with parameters. This set may include subschemas.</li></ul>
        </section>
        <section><name>OpenAPI</name>
            <t>An OpenAPI document is a self-contained or composite resource which defines or describes an API or elements of an API.</t>
            <t>OpenAPI specification (OAS) defines a set of objects identified by a keyword.</t>
            <t>An object is made up of Fields which can be an OpenAPI object or a JSONvalue. A JSON Schema is one of the OpenAPI objects (keyword: "schema").</t>
            <t>Unlike JSON Schema, keywords are interdependent and can only be used in the context of another keyword.</t>
        </section>
    </section>
    <section><name>Applicability of schemas to NTV</name>
        <section><name>Equivalence between JSON and NTV structures</name>
            <t>Any Json structure being an NTV structure, a first response is to consider that if the Json representation of an NTV structure is valid 
            for a schema then the NTV structure is valid for this schema.</t>
            <t>However, this argument is not valid because there is no direct correspondence between an NTV structure and a Json structure.</t>
            <t>For example, the following instances have a different json structure and will therefore not be able to respond to the same Json schema:</t>
                <sourcecode type="json">{"number1": [1, 2] }
{"number2": {"val1": 1, "val2": 2}}</sourcecode>
            <t>However, the NTV structure is identical for these two entities (an NTVlist entity composed of two NTVsingle entities).</t>
        </section>
    </section>    
  </middle>
  &nbsp;
  <back>
    <references><name>References</name>
      <references><name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4180.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml"/>
      </references>
      <references><name>Informative References</name>
        <reference anchor="TABLE" target="https://specs.frictionlessdata.io/table-schema/#language"><front>
          <title>Table Schema</title><author><organization>"FrictionLess"</organization></author><date year="2021"/></front></reference>
        <reference anchor="JSON-NTV" target="https://datatracker.ietf.org/doc/draft-thomy-json-ntv/"><front>
          <title>JSON semantic format (JSON-NTV)</title><author initials="P" surname="Thomy"></author><date year="2023"/></front></reference>
        <reference anchor="TAB-ANA" target="https://github.com/loco-philippe/tab-analysis/blob/main/docs/tabular_analysis.pdf"><front>
          <title>Tabular dataset analysis</title><author initials="P" surname="Thomy"></author><date year="2022"/></front></reference>                     
        <reference anchor="W3C TAB" target="https://www.w3.org/TR/2015/REC-tabular-data-model-20151217/"><front>
          <title>Recommendation : Model for Tabular Data and Metadata on the Web</title>
          <author><organization>"W3C"</organization></author><date year="17 December 2015"/></front></reference>                        
      </references>
    </references>
 </back>
</rfc>
