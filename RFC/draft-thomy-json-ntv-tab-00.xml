<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="rfc7991bis.rnc"?>
<!DOCTYPE rfc [<!ENTITY nbsp    "&#160;"><!ENTITY zwsp   "&#8203;"><!ENTITY nbhy   "&#8209;"><!ENTITY wj     "&#8288;">]>
<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="info"
  docName="draft-thomy-ntv-tab-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  version="2">

  <front>
    <title>NTV tabular format (NTV-TAB)</title>
    <seriesInfo name="Internet-Draft" value="draft-thomy-ntv-tab-00"/>
    <author fullname="Philippe THOMY" initials="P." surname="THOMY">
      <organization>Loco-labs</organization>
      <address>
        <postal>
          <street>476 chemin du gaf de Famian</street>
          <city>BOLLENE</city>
          <code>84 500</code>
          <country>FR</country>
        </postal>        
        <email>philippe@loco-labs.io</email>  
        <uri>https://github.com/loco-philippe/NTV/blob/main/README.md</uri>
      </address>
    </author> 
    <date year="2023" month="12" day="07"/>
    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>JSON</keyword>
    <keyword>semantic</keyword>
    <keyword>data interchange format</keyword>
    <keyword>tabular</keyword>
    <keyword>ABNF</keyword>
    <abstract pn="section-abstract">
      <t>This document describes a set of simple rules for unambiguously and concisely encoding tabular data into JSON Data Interchange Format.
       These rules are based on the NTV (Named and Typed Values) structure declined to tabular and multi-dimensional structures.</t>
      <t>The JSON-TAB format is its JSON translation.</t>
    </abstract>
  </front>
  &nbsp;
  <middle>
    <section><name>Introduction</name>
      <section><name>Presentation</name>
      </section>
      <section><name>Key design features</name>
      </section>
      <section><name>Conventions Used in This Document</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in all capitals, as shown here.</t>
        <t>This document also uses the following terms:</t><dl newline="true">    
          <dt><strong> JsonText, JsonValue, JsonObject, JsonMember, JsonElement, JsonArray, JsonNumber,
           JsonString, JsonFalse, JsonNull, JsonTrue :</strong></dt>
          <dd>These terms are defined in <xref target="JSON-NTV"/>.</dd>
          <dt><strong>NTV, NTVlist, NVlist, Vlist, TVlist, NTVsingle, NVsingle, TVsingle, Vsingle, NTVname, NTVtype, NTVvalue, 
          JsonNTVtype, JsonNTVname, JsonPrimitive, JsonUnnamed, JsonNamed:</strong></dt>
          <dd>These terms are defined in <xref target="JSON-NTV"/>.</dd>
          <dt><strong>Row, Column, Table, Cell:</strong></dt>
          <dd>These terms are defined in <xref target="W3C TAB"/>.</dd>
          <dt><strong>Dataset</strong></dt>
          <dd>A Dataset is equivalent to a Table</dd>
          <dt><strong>Field</strong></dt>
          <dd>A Field is equivalent to a Column</dd>
          <dt><strong>Dataset</strong></dt>
          <dd>A Dataset is equivalent to a Table</dd>
          
        </dl>
      </section>
    </section>
    <section><name>Tabular data</name>
      <section><name>Principles</name>
      <t><em><strong>Tabular data</strong> is data that is structured into rows, each of which contains information about some things. 
      Each row contains the same number of cells (although some of these cells may be empty), which provide values of properties of the thing described by the row.
       In tabular data, cells within the same column provide values for the same property of the things described by each row. 
       This is what differentiates tabular data from other line-oriented formats. </em><xref target="W3C TAB"/></t>
      <t>Two main uses are identified for tabular data:</t><ul>
        <li>a flow-oriented use for which each row is independent of the others. The dataset is then seen as a list of rows whose number can be variable. 
        This is for example the case of a list of measurements from a sensor.</li>
        <li>a structure-oriented use for which the rows are not independent and contribute to describing the same object. 
        This is for example the case of a grade table for a class which integrates the students, courses, periods, etc.</li></ul>
      <t>This document deals with this second use.</t>
      </section>
      <section anchor="tabular structure"><name>Tabular structure</name>
        <t>In structure-oriented use, columns and rows are not equivalent, the columns (or Fields) represent the 'semantics' of the data and the rows represent
         a specific combination of Field's values according to the structure defined by the tabular data (Dataset). The nature of the rows is often implicit.</t>
        <t>Two basic patterns are present in Datasets:<ul>
          <li><strong>Tree pattern</strong>: A tree is represented in tabular form by a list of paths between each leaf and the node. 
          The columns then represent the levels of the tree.</li>
          <li><strong>Matrix pattern</strong>: A matrix (or multi-dimensional data) is represented in tabular form by a column of the values of the matrix 
          and additional columns represent the coordinates of each of the values.</li></ul></t>
          <t><xref target="table1"/> and <xref target="table2"/> present an example of such patterns</t>
          <table anchor="table1" align="left" pn="table-1"><name>Tree pattern</name><thead>
            <tr><th>Root</th><th>level 1</th><th>level 2</th></tr></thead><tbody>
            <tr><td>A</td><td>B</td><td>D</td></tr>
            <tr><td>A</td><td>B</td><td>E</td></tr>
            <tr><td>A</td><td>C</td><td>F</td></tr>
            <tr><td>A</td><td>C</td><td>G</td></tr></tbody></table>
          <table anchor="table2" align="left" pn="table-2"><name>Matrix pattern</name><thead>
            <tr><th>Value</th><th>row</th><th>col</th></tr></thead><tbody>
            <tr><td>1</td><td>A</td><td>C</td></tr>
            <tr><td>2</td><td>A</td><td>D</td></tr>
            <tr><td>3</td><td>B</td><td>C</td></tr>
            <tr><td>4</td><td>B</td><td>D</td></tr></tbody></table>
        <t>Taking these structures into account leads to significant duplication of data. In the general case, Datasets mix these different structures.</t>
        <t>If we now observe the relationships between Fields, we can identify four main uses:</t><ul>
          <li><strong>association</strong>: this consists of coupling each value of a Field to a single value of another Field ("coupled" relationship between two fields),</li>
          <li><strong>classification</strong>: This involves grouping the data by category in order - for example - to be able to make a statistical use of it, 
           ("derived" relationship between two fields),</li>
          <li><strong>crossing</strong>: This consists of representing all the combinations between the two Fields, 
          such as in matrix representations ("crossed" relationship between two fields),</li>
          <li><strong>characterization</strong>: It corresponds to the documentation of defined properties (no specific relationship).</li></ul>
        <t><em>Example: Price list of different foods based on packaging for the year 2022.</em><xref target="table3"/></t>
          <table anchor="table3" align="left" pn="table-3"><name>Price list</name><thead>
            <tr><th>Id</th><th>Product</th><th>Food</th><th>Packaging</th><th>Weight</th><th>Price</th><th>Period</th><th>Availability</th></tr></thead><tbody>
            <tr><td>11</td><td>apple</td><td>fruit</td><td>bag</td><td>1 kg</td><td>1</td><td>2nd half 2022</td><td>Yes</td></tr>
            <tr><td>12</td><td>apple</td><td>fruit</td><td>cardboard</td><td>10 kg</td><td>9</td><td>2nd half 2022</td><td>Yes</td></tr>
            <tr><td>13</td><td>orange</td><td>fruit</td><td>bag</td><td>1 kg</td><td>2</td><td>2nd half 2022</td><td>end of 2022</td></tr>
            <tr><td>14</td><td>orange</td><td>fruit</td><td>cardboard</td><td>10 kg</td><td>18</td><td>2nd half 2022</td><td>end of 2022</td></tr>
            <tr><td>15</td><td>pepper</td><td>vegetable</td><td>bag</td><td>1 kg</td><td>1.5</td><td>2nd half 2022</td><td>end of 2022</td></tr>
            <tr><td>16</td><td>pepper</td><td>vegetable</td><td>cardboard</td><td>10 kg</td><td>13</td><td>2nd half 2022</td><td>end of 2022</td></tr>
            <tr><td>17</td><td>banana</td><td>fruit</td><td>bag</td><td>1 kg</td><td>0.5</td><td>2nd half 2022</td><td>Yes</td></tr>
            <tr><td>18</td><td>banana</td><td>fruit</td><td>cardboard</td><td>10 kg</td><td>4</td><td>2nd half 2022</td><td>Yes</td></tr>
            </tbody></table>       
        <t><em>We find here:</em></t><ul>
          <li><em>association: between "Packaging" and "Weight",</em></li>
          <li><em>classification: between "Product" and "Food",</em></li>
          <li><em>crossing: between "Product" and "Weight",</em></li>
          <li><em>characterization: between "Product" and "Availability"</em></li></ul>
      </section>
      <section><name>Field structure</name>
        <t>A Field is an ordered set of Cells.</t> 
        <t>To represent this structure, several representations are possible depending on the nature of the data:</t><ul>
          <li>the simplest format is to represent a Field by the list of Cells with the same order for all Fields. 
          This format is interesting when the data is little duplicated,</li>
          <li>when the data is repetitive, a second option is to represent on the one hand the list of different data and on the other hand their position in the list 
          (i.e. categorical data),</li>
          <li>another special case also concerns repetitive data for which one value is highly predominant (sparse data). 
          In this case, it is sufficient to provide only the position in the list of data except for the one that is predominant,</li>
          <li>a last option consists in representing the Field according to its dependence with another Field (coupled, derived or crossed relationship). 
          This leads to an optimized data volume.</li></ul>
      </section>
      <section><name>Representation</name>
        <t>Three representations are available for a tabular object : row-oriented (list of Rows), cells-oriented (list of Cells), field-oriented (list of Fields).</t>
        <t>The field-oriented representation is retained because it takes into account the semantics carried by the Fields as well as the inter-Field analysis presented above.</t>
        <t>A Dataset is then seen as a set of Fields representing the properties of the entire Dataset.</t>
        <t>The order of Fields or Rows is not relevant.</t>
      </section>
    </section>
    <section><name>NTV-TAB format</name>
      <section><name>NTV structure</name>
        <t>A Dataset is represented by the following NTV entities:</t><ul>
          <li>NTVcell represents a Cell. NTVcell is a NTVsingle.</li>
          <li>NTVfield represents a Field. NTVfield is a NTV entity depending on the format chosen to represent the Field (simple format, default format, optimized format).</li>
          <li>NTVdataset represents the Dataset. NTVdataset is a NVlist where the NTVname is the name of the Dataset and the NTVvalue is the list of NTVfields.</li></ul>
        <t>The JSON format of a NTVdataset is the JSON-NTV format.</t>
      </section>
      <section><name>simple NTVfield formats</name>
        <t>This category is the usual representation of a Field with different values (Full format) or with several identical values (Unique format).</t>
        <t><strong>Full format</strong> :</t> 
        <t>The NTVfield is a NTVlist where the NTVname is the name of the Field, the NTVtype is the default type of the NTVcells and 
        the NTVvalue is the list of NTVcells.</t><ul empty="true">
          <li><em>Example JsonNTVvalue ( "price" Field)</em> : <ul empty="true">
            <li><em>[ 1, 9, 2, 18, 1.5, 13, 0.5, 4 ]</em></li></ul></li></ul>
        <t><strong>Unique format</strong> :</t>
        <t>The NTVfield is a NTVsingle identical to the NTVcell.</t><ul empty="true">
          <li><em>Example JsonNTVvalue ( "period" Field)</em> : <ul empty="true"> 
            <li><em>"2nd half 2022"</em></li></ul></li></ul>
        <t>Note : </t><ul empty="true">
          <li>The Unique format also makes it possible to represent tabular metadata</li></ul>
      </section>
      <section><name>default NTVfield formats</name>
        <t>This category completes the simple formats with the other most common representations of a Field : </t><ul>
          <li>Categorical Field (Complete format)</li>
          <li>Periodic Field (Primary format)</li>
          <li>Sparse Field (Sparse format)</li></ul>
        <t>The NTVfield is a NVlist where the NTVname is the name of the Field and the NTVvalue is the list of two NTVentities.</t>
        <t><strong>Complete format</strong> :</t> 
        <t>The "complete format" is equivalent to the format used to store categorical variables.</t>
        <t>The Field is a NVlist composed with two NTV entities :</t><ul>
          <li>Component: TVlist of different Field NTVcells (Codec),</li>
          <li>Coding: Vlist of indexes of NTVcells in Component (Keys)</li></ul>
        <t>The list of values is reconstituted by replacing the integers in the coding Vlist with the value at the coding index in the component TVlist 
        (e.g. pandas categories and codes).</t><ul empty="true">
          <li><em>Example JsonNTVvalue ( "product" Field)</em> : <ul empty="true">
            <li><em>[ [ "orange" , "pepper" , "apple" , "banana" ], [ 2, 2, 0, 0, 1, 1, 3, 3 ] ]</em></li></ul></li></ul>
        <t><strong>Sparse format</strong> :</t> 
        <t>A specific format (one dimensional sparse LIL format) is used for sparse data. It is defined by:</t><ul>
          <li>'fill_value': it should be most common value</li>
          <li>'sp_value': it is a list storing only values distinct from the 'fill_value'</li>
          <li>'sp_index': list of index of 'sp-value' in the sparse data list</li></ul>
        <t>The Field is a NVlist composed with two NTV entities :</t><ul>
          <li>Component: TVlist of 'sp_value' completed with 'fill_value' ,</li>
          <li>Coding: Vlist of 'sp_index' completed with -1</li></ul>
        <t>The list of values is equivalent to the list of 'fill_value' where the values with index in the Coding Vlist 
        are replaced by the corresponding value in the Component TVlist.</t><ul empty="true">
          <li><em>Example JsonNTVvalue ( "food" Field)</em> : <ul empty="true">
            <li><em>[ [ "vegetable" , "vegetable" , "fruit"], [ 4, 5, -1 ] ]     'fruit' is the 'fill_value'</em></li></ul></li></ul>
        <t><strong>Primary format</strong> :</t> 
        <t>This format is equivalent to the Complete format where the Keys Vlist is calculated with the "repetition coefficient".</t>
        <t>The Field is a NVlist composed with two NTV entities :</t><ul>
          <li>Component: TVlist of different Field NTVcells (Codec),</li>
          <li>Coding: Vlist with a single integer (Repetition coefficient)</li></ul>
        <t>The Keys list is generated with the formula:</t><ul empty="true">
          <li>keys[ikey] = ( ikey % ( coef * period ) ) // coef</li>
          <li>where:<ul empty="true">
            <li>keys: is the Keys list</li>
            <li>ikey: is the index of a key value</li>
            <li>coef: is the Repetition coefficient</li>
            <li>period: is the length of Codec</li></ul></li>
          <li><em>Example: coef = 2, period = 3, Keys length = 12</em><ul empty="true">
            <li><em>keys = [0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2]</em></li></ul></li></ul>         
        <t>The Repetition coefficient is the number of adjacent identical values in the Keys list.</t><ul empty="true">
          <li><em>Example "packaging"</em> : <ul empty="true">
            <li><em>component: [ "bag" , "cardboard" ]</em></li>
            <li><em>Coefficient: 1</em></li>
            <li><em>(implicit Keys :  [ 0, 1, 0, 1, 0, 1, 0, 1 ] )</em></li></ul></li>
          <li><em>Example "product"</em> : <ul empty="true">
            <li><em>component: [ "apple" , "orange" , "pepper" , "banana" ] </em></li>
            <li><em>Coefficient: 2</em></li>
            <li><em>(implicit Keys :  [ 0, 0, 1, 1, 2, 2, 3, 3 ] )</em></li></ul></li></ul>
      </section>
      <section><name>Optimized NTVfield formats</name>
        <t>This category reduces the weight of complete format with optimized keys. The length of keys is reduced with using of derived (Relative format)
         or coupled (Implicit format) relationships between two fields.</t>
        <t>The NTVfield is a NVlist where the NTVname is the name of the field and the NTVvalue is the list of two or three NTVentities.</t>
        <t><strong>Implicit format</strong> :</t> 
        <t>This representation is associated with "coupled" Fields. These Fields have a one-to-one correspondence.</t>
        <t>The Field is a NVlist composed with two NTV entities :</t><ul>
          <li>Component: TVlist of different field NTVcells (Codec),</li>
          <li>Ref: Vsingle entity index or name of the coupled Field.</li></ul>
        <t>This format is equivalent to the complete format where Keys is the Keys of the Field (with Complete format) defined by Ref.</t><ul empty="true">
          <li><em>Example JsonNTVvalue ( "weight" Field is associated with "packaging" Field )</em> : <ul empty="true">
            <li><em>[ [ "1 kg" , "10 kg" ], "packaging"]</em></li>
            <li><em>( implicit Keys :  [ 0, 1, 0, 1, 0, 1, 0, 1 ] )</em></li></ul></li></ul>
        <t><strong>Relative format</strong> :</t> 
        <t>This representation is associated with "derived" Fields. These Fields have a one-to-many correspondence.</t>
        <t>The values of a "derived" Field are inferred from the values of the Field defined by Ref.</t>
        <t>The Field is a NVlist composed with three NTV entities :</t><ul>
          <li>Component: TVlist of different field NTVcells (Codec),</li>
          <li>Ref: Vsingle entity index or name of the coupled Field,</li>
          <li>Coding : Vlist of relative indexes of NTVcells in Component (Relative Keys).</li></ul>
        <t>This format is equivalent to the Complete format where the Keys Vlist is obtained by replacing the values of the Keys Vlist of the associated Field
         with the corresponding values in the Relative Keys (the length of the Relative Keys is the length of the Codec of the associated Field).</t><ul empty="true">
          <li><em>Example JsonNTVvalue ( "food" Field is associated with "product" Field )</em> : <ul empty="true">
            <li><em>[ [ "fruit" , "vegetable" ], "product", [ 0, 1, 0, 0 ] ]</em></li>
            <li><em>(the Vlist Keys is obtained by replacing the values 0, 1, 2, 3 of the Vlist Keys of the "product" Field by the values 0, 1, 0, 0 
            of the Relative Keys i.e.: [ 0, 0, 0, 0, 1 , 1, 0, 0] )</em></li></ul></li></ul>
      </section>
      <section><name>Synthesis</name>
        <t>The NTVfield structure corresponding to the format defined above are in <xref target="table4"/>:</t>
        <table anchor="table4" align="center" pn="table-4"><name>NTVfield formats</name><thead>
          <tr><th colspan="2" align="center">Structure</th><th align="center">Component</th><th align="center">Ref</th><th align="center">Coding</th></tr>
          <tr><th align="center">format</th><th align="center">NTV</th><th align="center">TVlist</th><th align="center">Vsingle</th><th align="center">Vlist</th></tr></thead><tbody>
          <tr><td>Relative</td><td><t>NTVlist</t><t>len = 3</t></td><td>Codec</td><td><t>index</t><t>or name</t></td><td><t>Relative Keys</t><t>len &lt; len(Field)</t></td></tr>
          <tr><td>Complete</td><td><t>NTVlist</t><t>len = 2</t></td><td>Codec</td><td> </td><td><t>Keys</t><t>len = len(Field)</t></td></tr>
          <tr><td>Sparse</td><td><t>NTVlist</t><t>len = 2</t></td><td><t>sp_value</t><t>+ fill_value</t></td><td> </td><td><t>sp_index + -1</t><t>1 &lt; len &lt; len(Field)</t></td></tr>
          <tr><td>Implicit</td><td><t>NTVlist</t><t>len = 2</t></td><td>Codec</td><td><t>index</t><t>or name</t></td><td> </td></tr>
          <tr><td>Primary</td><td><t>NTVlist</t><t>len = 2</t></td><td>Codec</td><td> </td><td><t>coef</t><t>len = 1</t></td></tr>
          <tr><td>Unique</td><td colspan="4" align="center">NTVsingle</td></tr>
          <tr><td>Full</td><td colspan="4" align="center">NTVlist &nbsp; &nbsp; &nbsp; &nbsp; len = len(Field)</td></tr></tbody></table>
        <t> Three levels are available to convert tabular data in JSON structure <xref target="table5"/>.</t><ul>
          <li><t><strong>Level 0: "simple"</strong> is the usual representation of tabular data.</t><t>Fields are converted with the Simple or Unique format.</t></li>
          <li><t><strong>Level 1: "default"</strong> avoids duplication of information by adding simple encoding.</t>
            <t>Fields are converted according to their own structure (simple, unique, categorical, sparse, periodic). </t></li>
          <li><t><strong>Level 2: "optimize"</strong> avoids duplication of information and minimizes encoding. It is the usual representation of multi-dimensional data.</t>
            <t>This level requires an analysis of the relationships between Fields ("partition")</t></li></ul>
        <table anchor="table5" align="center" pn="table-5"><name>NTVfield levels</name><thead>
          <tr><th colspan="2" align="center">Level</th><th colspan="2" align="center">Structure</th></tr>
          <tr><th align="center">n°</th><th align="center">mode</th><th align="center">Type Field</th><th align="center">format</th></tr></thead><tbody>
          <tr><td rowspan="2">0</td><td rowspan="2">simple</td><td>Unique</td><td>Unique</td></tr>
          <tr><td>Simple</td><td>Full</td></tr>
          <tr><td rowspan="5">1</td><td rowspan="5">default</td><td>Unique</td><td>Unique</td></tr>
          <tr><td>Simple</td><td>Full</td></tr>
          <tr><td>Sparse</td><td>Sparse</td></tr>
          <tr><td>Categorical</td><td>Complete</td></tr>
          <tr><td>Periodic</td><td>Primary</td></tr>
          <tr><td rowspan="6">2</td><td rowspan="6">optimize</td><td>Unique</td><td>Unique</td></tr>
          <tr><td>Root coupled</td><td>Full</td></tr>
          <tr><td>Root derived</td><td>Complete</td></tr>
          <tr><td>Primary</td><td>Primary</td></tr>
          <tr><td>Derived</td><td>Relative</td></tr>
          <tr><td>Coupled</td><td>Implicit</td></tr></tbody></table>
      </section>
    </section>
    <section><name>Examples</name>
      <section><name>Field examples</name>
        <t>The example in <xref target="tabular structure"/>have the following JSON representation <xref target="table6"/>:</t>
        <table anchor="table6" align="center" pn="table-6"><name>NTVfield examples</name><thead>
          <tr><th align="center">Format</th><th align="center">JsonNTV Representations</th></tr></thead><tbody>
          <tr><td>Full</td><td><t>{ "price::float": [ 1, 9, 2, 18, 1.5, 13, 0.5, 4 ] }</t>
            <t>{ "price": [ 1, 9, 2, 18, 1.5, 13, 0.5, 4 ] }</t>
            <t>[ 1, 9, 2, 18, 1.5, 13, 0.5, 4 ]</t></td></tr>
          <tr><td>Complete</td><td><t>{"product":[{"::string":["orange","pepper","apple","banana"]},[2,2,0,0,1,1,3,3]]}</t>
            <t>{"product": [ ["orange","pepper","apple","banana"], [2, 2, 0, 0, 1, 1, 3, 3] ]}</t>
            <t>[ ["orange","pepper","apple","banana"], [2, 2, 0, 0, 1, 1, 3, 3] ]</t></td></tr>                  
          <tr><td>Unique</td><td><t>{ "period": "2nd half 2022" }</t><t>"2nd half 2022"</t></td></tr>        
          <tr><td>Implicit</td><td><t>{ "weight": [ { "::string": [ "1 kg" , "10 kg" ] }, "packaging" ] }</t><t>[ [ "1 kg" , "10 kg" ], 3 ]</t></td></tr>                  
          <tr><td>Relative</td><td><t>{"food": [ {"::string": [ "fruit" , "vegetable" ]}, "product", [ 0, 1, 0, 0 ]] }</t>
            <t>[ [ "fruit" , "vegetable" ], 1, [ 0, 1, 0, 0 ] ]</t></td></tr>                  
          <tr><td>Sparse</td><td><t>{"food": [ {"::string": [ "vegetable", "vegetable", "fruit" ]}, [ 4, 5, -1]] }</t>
            <t>[ [ "vegetable", "vegetable", "fruit" ], [ 4, 5, -1] ]</t></td></tr>                  
          <tr><td>Primary</td><td><t>{"packaging": [ {"::string": [ "cardboard", "bag" ]}, [1] ] }</t><t>[ [ "cardboard", "bag" ], [1] ]</t>
          <t>{"product": [{"::string": ["apple", "orange", "peppers", "banana"]}, [2]]}</t><t>[ [ "apple", "orange", "peppers", "banana" ], [2] ]</t></td></tr>                  
        </tbody></table>
      </section>
      <section><name>Properties</name>
      
      </section>
        <section><name>Properties</name>
        
        </section>
      <section><name>Dataset examples</name>
        <t>The examples in <xref target="table7"/> below illustrate the optimize level:</t>
        <table anchor="table7" align="center" pn="table-7"><name>optimize level examples</name><thead>
            <tr><th colspan="2" align="center">Data</th><th align="center">Optimize level</th></tr>
            <tr><th align="center">category</th><th align="center">Full format</th><th align="center">JsonNTV</th></tr></thead><tbody>
            <tr><td>matrix</td><td><t>[['a', 'a', 'b', 'b', 'c', 'c'],</t><t>[10, 20, 10, 20, 10, 20],</t><t>[1, 2, 3, 4, 5, 6]]</t></td>
              <td><t>[[['a', 'b', 'c'], [2]],</t><t>[[10, 20], [1]],</t><t>[1, 2, 3, 4, 5, 6]]</t></td></tr>
            <tr><td>single</td><td><t>[[1, 2, 3, 4, 5, 6],</t><t>['a', 'a', 'a', 'a', 'a', 'a']]</t></td><td><t>[[1, 2, 3, 4, 5, 6],</t><t>'a']</t></td></tr>
            <tr><td>complete</td><td>[[1, 2, 3, 3, 5, 5]]</td><td>[[[1, 2, 3, 5], [0, 1, 2, 2, 3, 3]]]</td></tr>         
            <tr><td>coupled</td><td><t>[[1, 2, 3, 3, 5, 5],</t><t> ['a', 'b', 'c', 'c', 'e', 'e']]</t></td><td>
              <t>[[[1, 2, 3, 5], [0, 1, 2, 2, 3, 3]],</t><t> [['a', 'b', 'c', 'e'], 0]]</t></td></tr>
            <tr><td>derived</td><td><t>[[1, 2, 3, 4, 5, 6],</t><t>['a', 'a', 'b', 'b', 'c', 'c'],</t><t>[10, 10, 10, 10, 20, 20]]</t></td>
              <td><t>[[1, 2, 3, 4, 5, 6],</t><t> [['a', 'b', 'c'], [0, 0, 1, 1, 2, 2]],</t><t>[[10, 20], 1, [0, 0, 1]]]</t></td></tr>
            <tr><td><t>matrix +</t><t>coupled</t></td><td><t>[['a', 'a', 'b', 'b', 'c', 'c', 'd', 'd'],</t><t>[10, 20, 10, 20, 10, 20, 10, 20],</t>
              <t>['t1', 't1', 't2', 't2', 't3', 't3', 't4', 't4'],</t><t>[1, 2, 3, 4, 5, 6, 7, 8]]</t></td>
              <td><t>[[['a', 'b', 'c', 'd'], [2]],</t><t>[[10, 20], [1]],</t><t>[['t1', 't2', 't3', 't4'], 0],</t><t> [1, 2, 3, 4, 5, 6, 7, 8]]</t></td></tr>
            <tr><td><t>matrix +</t><t>coupled +</t><t>derived</t></td><td><t>[['a', 'a', 'b', 'b', 'c', 'c', 'd', 'd'],</t><t>[10, 20, 10, 20, 10, 20, 10, 20],</t>
              <t>['t1', 't1', 't2', 't2', 't3', 't3', 't4', 't4'],</t><t>[100, 100, 200, 200, 200, 200, 200, 200],</t><t>[1, 2, 3, 4, 5, 6, 7, 8]]</t></td>
              <td><t>[[['a', 'b', 'c', 'd'], [2]],</t><t>[[10, 20], [1]],</t><t>[['t1', 't2', 't3', 't4'], 0],</t><t> [[100, 200], 0, [0, 1, 1, 1]],</t>
              <t> [1, 2, 3, 4, 5, 6, 7, 8]]</t></td></tr></tbody></table>
        <t>The examples in <xref target="table8"/> below illustre NTVdataset with a length equal to 0, 1 or 2:</t>
        <table anchor="table8" align="center" pn="table-8"><name>NTVdataset with length 0, 1 or 2</name><tbody>
          <tr><td>[ ] or { }</td><td><em>Empty NTVdataset</em></td></tr>
          <tr><td>[25]	or [[25]]</td><td><em>NTVdataset with 1 NTVfield and length 1</em></td></tr>
          <tr><td>[2, 1]	or [[2], [1]]	 or [2, [1]]</td><td><em>NTVdataset with 2 NTVfield and length 1</em></td></tr>
          <tr><td>[[2, 1]]</td><td><em>NTVdataset with 1 NTVfield and length 2</em></td></tr>
          <tr><td>[[2, 1], [4, 3]]</td><td><em>NTVdataset with 2 NTVfield and length 2</em></td></tr></tbody></table>
      </section>
    </section>    
    <section><name>Parsing a JSON-value</name>
      <t>A NTV parser generates a NTV entity from a JSON-value.</t>
      <t>The decoding NTV entity is directly converted into the NTVdataset and a list of NTVfields.</t>
      <t>For each NTVfield the format is deduced following the structure defined in the table xxx.</t>
      <t>For each format, a decoder converts the NTVvalue of the NTVfield into the chosen object.</t>
      <t><em>Note :</em></t><ul empty="true">
        <li><em>Several NTVvalue are ambiguous to deduce the Field format : </em><ul>
          <li><em>[ list-data, integer, list-integer ] : Full or Relative format ?</em></li>
          <li><em>[ list-data, string, list-integer ] : Full or Relative format ?</em></li>
          <li><em>[ list-data, integer ]  : Full or Implicit format ?</em></li>
          <li><em>[ list-data, string ]  : Full or Implicit format ?</em></li>
          <li><em>[ list-data, list-integer ] : Full or Complete/Sparse/Primary format ?</em></li></ul></li>
        <li><em>The full format is not retained for those NTVvalue.</em></li>
        <li><em>To avoid this ambiguity, precautions can be taken for data with a Full format:</em><ul>
          <li><em>a name can be added to the list-data (e.g. { "data": list-data}),</em></li>
          <li><em>the order of data can be changed (e.g. [ integer, list-data ])</em></li>
          <li><em>a type can be added (e.g. { "::json": [ list-data, list-integer ] } )</em></li>
          <li><em>an additional field can be added (e.g. [ list-data, integer, list-integer, {"format": "full"} ] ).</em></li></ul></li></ul>
    </section>
    &nbsp;
    <section anchor="IANA"><name>IANA Considerations</name>
      <t>Any JsonValue is a JsonNTVValue and conversely, any JsonNTVvalue is a JsonValue.</t>
      <t>Thus, any JSON data may or may not be treated as JsonNTV data, so there is no need to create a specific MIME media type for JsonNTV.</t>
      <t>All properties of the MIME media type "application/json" are applicable.</t>
    </section>
    <section anchor="Security"><name>Security Considerations</name>
      <t>The format used for NTV data exchanges is the JSON format. 
      So, all the security considerations of <xref target="RFC8259"/> apply.</t>
      <t>The NTV structure provides no cryptographic integrity protection of any kind.</t>
    </section>
  </middle>
  &nbsp;
  <back>
    <references><name>References</name>
      <references><name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7946.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6901.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3339.xml"/>
      </references>
      <references><name>Informative References</name>
        <reference anchor="JSON-NTV" target="https://www.ietf.org/archive/id/draft-thomy-json-ntv-01.html"><front>
          <title>Internet-Draft JSON-NTV</title><author initials="P" surname="Thomy"></author><date year="2022"/></front></reference>      
        <reference anchor="OLC" target="https://github.com/google/open-location-code"><front>
          <title>Open Location Code</title><author><organization>"Google"</organization></author><date year="2016"/></front></reference>            
        <reference anchor="W3C TAB" target="https://www.w3.org/TR/2015/REC-tabular-data-model-20151217/"><front>
          <title>Recommendation : Model for Tabular Data and Metadata on the Web</title>
          <author><organization>"W3C"</organization></author><date year="17 December 2015"/></front></reference>            
        <reference anchor="ISO 3166-1 alpha-2" target="https://www.iso.org/standard/72482.html"><front>
          <title>Codes for the representation of names of countries and their subdivisions - Part 1: Country code</title>
          <author><organization>"ISO"</organization></author><date year="2020"/></front></reference>            
      </references>
    </references>
    &nbsp;
    <section><name>Appendixxxxxx</name>
    </section>
    <section anchor="Acknowledgements" numbered="false"><name>Acknowledgements</name>
      <t>TBD</t>
    </section>
    <section anchor="Contributors" numbered="false"><name>Contributors</name> 
      <t>TBD</t>
    </section>
 </back>
</rfc>
